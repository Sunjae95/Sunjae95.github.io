---
title: ë°±ì¤€ - í† ë§ˆí† 
date: 2022-04-17 00:00:00 +/-TTTT
categories: [Algorithm, Baekjoon]
tags: [baekjoon, algorithm, bfs, graph] # TAG names should always be lowercase
---

# í† ë§ˆí†  - 7576ë²ˆ

ë¬¸ì œë§í¬: [í† ë§ˆí† ](https://www.acmicpc.net/problem/7576)

## ğŸ¤”ì ‘ê·¼ ë°©ë²•

ìµì€ í† ë§ˆí† ì™€ ìµì§€ ì•Šì€ í† ë§ˆí† ê°€ ë¶™ì–´ìˆê³  ë‹¤ìŒë‚ ì´ ëœë‹¤ë©´, ìµì§€ ì•Šì€ í† ë§ˆí† ëŠ” ìµê²Œ ë˜ëŠ” ê²ƒì„ ë³´ê³  `ì ì°¨ í¼ì§€ëŠ” ê²ƒ`ì´ ë¨¸ë¦¿ì†ì— ê·¸ë ¤ì¡Œë‹¤. ê·¸ë˜ì„œ `ê·¸ë˜í”„ íƒìƒ‰`ê³¼ ì—°ê´€ ìˆë‹¤ê³  ìƒê°í•˜ê²Œ ëë‹¤.

`ìµœì†Œ ì¼ìˆ˜`ë¥¼ êµ¬í•˜ë¼ëŠ” ì§€ë¬¸ì„ ë³´ê³  `BFS`ë¥¼ ìƒê°í•˜ê²Œ ëë‹¤. BFS íŠ¹ì„±ìƒ ê°™ì€ depsì˜ ë…¸ë“œë¥¼ íƒìƒ‰í•˜ê¸° ë•Œë¬¸ì— ì´ë¥¼ `deps = ë‚ ì§œ`ë¼ê³  ìƒê°í–ˆë‹¤.

ê¸°ì¡´ BFSëŠ” ì²« ì‹œì‘ì´ í•˜ë‚˜ì˜ ë…¸ë“œë¼ë©´ ì—¬ê¸°ì„œëŠ” í† ë§ˆí† ê°€ 1ê°œ ì´ìƒì¼ ìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì— `íƒìƒ‰ ì‹œ 1ê°œ ì´ìƒì˜ ë…¸ë“œ`ë¥¼ ë„£ì–´ì£¼ì–´ BFS ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í–ˆë‹¤.

## ğŸ¤—í’€ì´ ë°©ë²•

1. ë°°ì—´ ì…ë ¥ ì‹œ ìµì€ í† ë§ˆí† (ìˆ«ì 1) ì…ë ¥ ì‹œ total(ì „ì²´ í† ë§ˆí† )ì—ì„œ ë¹¼ì£¼ê³  í† ë§ˆí† ê°€ ë¹ˆ ê³³(ìˆ«ì -1)ì´ë¼ë©´ ì´ ë˜í•œ totalì—ì„œ ë¹¼ì£¼ì—ˆë‹¤.
2. `ìµì€ í† ë§ˆí†  ì…ë ¥` ì‹œ BFSíƒìƒ‰ì— ì‚¬ìš©ë  `Queueì— ë„£ì–´` ì£¼ì—ˆë‹¤.
3. ê¸°ì¡´ BFSì™€ ë™ì¼ í•˜ì§€ë§Œ days(ë‚ ì§œ)ë¥¼ countingí•˜ëŠ”ê²ƒì€ í˜„ì¬ `Queueì— ë“¤ì–´ìˆëŠ” ë…¸ë“œê°€ ë‹¤ ì—†ì–´ì ¸ì•¼ counting`ì„ í–ˆë‹¤.
4. ë°©ë¬¸ê¸°ì¤€: ë°•ìŠ¤ ë²”ìœ„ì¸ì§€, ì´ë¯¸ ë°©ë¬¸ì„ í–ˆëŠ”ì§€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ Queueì— ì¶”ê°€í• ì§€ íŒë‹¨í–ˆë‹¤.
5. Queueì— ì¶”ê°€ì‹œ totalì—ì„œ 1ì”© ë¹¼ì£¼ì—ˆë‹¤.
6. totalì´ 0ì´ ëœë‹¤ë©´ ëª¨ë‘ ìµê²Œ ë˜ì–´ daysë¥¼ ì¶œë ¥ ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ -1 ì¶œë ¥

```java
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	static int ROW, COLUMN, total;
	static int days = -1;
	static int[][] board;
	static boolean[][] isVisited;
	static int[] dr = {0,0,1,-1};
	static int[] dc = {1,-1,0,0};
	// Queueì—ì„œ ì¢Œí‘œë¡œ ì‚¬ìš©í•˜ê¸° ìœ„í•œ class
	private static class Pos {
	   int r, c;

	   Pos(int r, int c) {
	      this.r = r;
	      this.c = c;
	   }
	}

	public static void main(String[] args) throws IOException {
		// ì…ë ¥
		st = new StringTokenizer(br.readLine());
		COLUMN = Integer.parseInt(st.nextToken());
		ROW = Integer.parseInt(st.nextToken());
		board = new int[ROW][COLUMN];
		isVisited = new boolean[ROW][COLUMN];
		total = ROW * COLUMN;
		Queue<Pos> queue = new LinkedList<>();

		for(int r=0; r < ROW ; r++) {
			st = new StringTokenizer(br.readLine());
			for(int c=0; c < COLUMN; c++) {
				int tomato = Integer.parseInt(st.nextToken());
				switch (tomato) {
					case 1: {
						queue.add(new Pos(r,c));
						total -= tomato;
						break;
					}
					case -1: {
						total += tomato;
						break;
					}
					default: {
						total += tomato;
					}
				}
				board[r][c] = tomato;
			}
		}
		//BFS
		while(queue.size() > 0) {
			int nowCount = queue.size();
			days++;

			while(nowCount-- > 0) {
				Pos now = queue.poll();

				for(int i=0; i<4; i++) {
					int nextR = now.r + dr[i];
					int nextC = now.c + dc[i];
					boolean isRange = nextR < 0 || nextR >=ROW || nextC < 0 || nextC >= COLUMN;

					if(isRange || isVisited[nextR][nextC]) continue;

					isVisited[nextR][nextC] = true;

					if(board[nextR][nextC] == 0) {
						queue.add(new Pos(nextR, nextC));
						isVisited[nextR][nextC] = true;
						total--;
					}
				}
			}
		}

		if(total > 0) {
			System.out.println(-1);
		} else {
			System.out.println(days);
		}
	}
}
```
